
# C++ 笔记

## 命名空间

C++ 中以 `.h` 为后缀的头文件中的符号仍是全局范围的，而不包含 `.h` 的头文件的符号则包含在命名空间之中，需要通过 `::` 操作符访问，例如 `:::Cpp std::cout`。若要自定义命名空间，可以使用 `namespace` 关键字，如 `:::Cpp namespace A{ ... }`。

需要注意的是，一个命名空间的定义可以分散在不同文件，或者同一文件的不同位置中。此外，命名空间还可以嵌套定义，此时可以通过叠加使用 `::` 操作符来访问内层命名空间的符号。

为了避免繁琐地使用 `::` 操作符，可以通过 `using namespace` 指令将指定命名空间的所有符号引入到当前作用域中。若两个命名空间有相同的符号，还都引入到了当前作用域，则会产生冲突并报错。

C++ 中最常见的命名空间是 `std`，它包含了大量的标准库函数和对象，例如 `cout`、`cin`、`endl`、`string`、`vector` 等。




<br>

## 字符串

### 构造函数

- `string()` 返回一个空字符串
- `string(const string& str)` 返回一个与 str 相同的字符串
- `string(const string& str, size_t pos, size_t len = npos)` 返回 str 中从 pos 开始的 len 个字符
    - 若 len 没有被指定或者超出范围，则会返回从 pos 开始的所有字符
    - 需要注意的是，当传入的不是 string 时，第二个参数会被认为是长度
- `string(const char* s)` 返回一个与 s 相同的字符串
- `string(const char* s, size_t n)` 返回 s 中的前 n 个字符
- `string(size_t n, char c)` 返回 n 个字符 c

### 查询长度

- `size()` 返回字符串的长度
- `length()` 返回字符串的长度，与 `size()` 相同，但更推荐使用 `size()`
- `empty()` 判断字符串是否为空

### 修改字符串

- `append(...)` 向原字符串末尾添加字符串，参数与构造函数一致
- `assign(...)` 为字符串赋值新的内容，参数与构造函数一致
- `insert(pos, ...)` 从 pos 开始插入字符串，原 pos 位置的字符向后移，后续参数与构造函数一致
- `erase(pos = 0, len = npos)` 删除从 pos 开始的 len 个字符
- `replace(pos, len, ...)` 替换字符串中的字符，后续参数与构造函数一致

上述方法都会返回一个指向当前字符串的引用，

### 子字符串

- `substr(pos = 0, len = npos)` 返回一个新字符串，包含从 pos 开始的 len 个字符

需要注意的是，这些方法中的 pos 参数不能大于字符串的长度，否则会报错。

### 搜索比较

`compare` 方法可以用于比较两个字符串，返回值为 0 时表示相等，大于 0 时表示当前字符串大于参数字符串，小于 0 时表示当前字符串小于参数字符串。大于的定义是第一个不匹配的字符在当前字符串中更大，或者全都匹配但当前字符串更长，小于同理。`compare` 方法的形式有：

- `compare(str)` 比较当前字符串和 str
- `compare(pos, len, str)` 比较当前字符串的子字符串和 str

`find` 方法可以用于搜索字符串，返回值为第一个匹配的位置，若没有匹配则返回 `string::npos`。`string::npos` 的值为 -1，若用在 len 参数中则意为到字符串末尾。`find` 方法的形式有：

- `find(str, pos = 0)` 在当前字符串中搜索 str，从 pos 开始
- `find(char, pos = 0)` 在当前字符串中搜索字符 char，从 pos 开始

### 字符串字面量

字符串字面量被存储在常量区，可以使用 `const char*` 类型的指针来指向它，其值不可修改。若要修改字符串的值，可以使用 `char[]` 类型的数组，将字符串字面量拷贝到数组中。

此外，字符串字面量还可以使用 `sizeof` 运算符来获取长度，返回的长度包括结尾的空字符。





<br>

## 文件 I/O

C++ 中许多对象都定义了读写的方式，可以通过流操作符 `<<` 和 `>>` 来进行输入输出。流操作符的左侧是流对象，右侧是要输入或输出的数据，操作符方向决定了数据的流向，其中 `<<` 是流插入操作符，用于输出，`>>` 是流提取操作符，用于输入。

头文件 `iostream` 定义了三个重要的流对象：

- `cin` 标准输入流，istream 类的对象，对应于 stdin
- `cout` 标准输出流，ostream 类的对象，对应于 stdout
- `cerr` 标准错误流，ostream 类的对象，对应于 stderr

头文件 `fstream` 定义了三个重要的类，其构造函数分别为：

- `ifstream(const char* filename, ios::openmode mode = ios::in)`
- `ofstream(const char* filename, ios::openmode mode = ios::out)`
- `fstream(const char* filename, ios::openmode mode = ios::in | ios::out)`

其中 mode 参数的标志有：

- `ios::in` 以输入模式打开文件，若不存在则创建
- `ios::out` 以输出模式打开文件，若不存在则创建，若存在则清空
- `ios::binary` 以二进制模式而不是文本模式打开文件
- `ios::ate` 打开时将位置切换到文件末尾
- `ios::app` 每次写操作前都将位置切换到文件末尾
- `ios::trunc` 打开时丢弃文件内容

这些标志是位掩码类型，可以使用或运算符组合使用。





<br>

## 内存管理

可以使用 `new` 和 `delete` 运算符来动态分配和释放内存。

`new` 运算符会先为对象分配内存，然后调用构造函数初始化对象，最后返回对象的地址，其语法为 `new type new-initializer`。对于内置数据类型，如果不使用初始化器，程序便不会进行初始化，而对于类类型，则会调用默认构造函数。

若 type 是非数组类型，则可以使用 `(...)` 作为初始化器；若 type 是数组类型，则可以使用 `{...}` 初始化器列表，它会按照从前往后逐一初始化对象，剩余对象会调用默认构造函数来初始化，示例如下：

- `new int` 创建一个未初始化的整数
- `new int(2)` 创建一个被初始化为 2 的整数
- `new int[10]{}` 创建一个被初始化为 0 的整数数组
- `new int[10]{1, 2, 3}` 创建一个前三位被初始化为 1、2、3，后七位被初始化为 0 的整数数组

`delete` 运算符会先调用对象的析构函数，然后释放对象的内存，有两种形式：

- `delete ptr` 用于非数组对象，只会对指向的第一个对象起作用
- `delete [] ptr` 用于数组对象，会对每个对象依次调用析构函数并释放内存

需要注意的是，`new` 运算符在分配失败时会抛出 `std::bad_alloc` 异常，而 `delete` 一般不会，还可以用于空指针。





<br>

## 指针与引用

[] 和 () 的优先级高于 *，下列指针定义的含义依次为：

- `int * p[3]` 元素为整数指针的数组
- `int (* p)[3]` 指向整数数组的指针，每一步跨度为 12 字节
- `int (* p[3])()` 元素为指向函数的指针的数组

与指针不同，引用并不是一个对象，而是一个别名，它必须在定义时初始化，且不能再改变。引用的定义形式为 `type & name = object`，其中 type 是引用的类型，name 是引用的名字，object 是引用的对象。

需要注意的是，引用的对象类型不能是数组，也不能是引用，但可以是指针。引用还可以作为函数的返回值，这可以实现将函数调用放在赋值语句的左侧的效果。

可以在变量类型之前加上 const 修饰符来定义常量，常量的值不能被修改。如果一个整数被定义为 `const int`，那么它被传递给 `int *` 或者 `int &` 时就会报错，必须传递给 `const int *` 或者 `const int &`。

const 和指针的关系为：

- `const type * p` `type const * p` 指针指向的值为常量，但是可通过其他指针修改
- `type * const p` 指针为常量，不可指向其他值
- `const type * const p` 指针和指向的值皆为常量，不可修改




<br>

## 面向对象

### 类与对象

类的定义为：

```cpp
class ClassName {
public:          // 访问修饰符
    void func(); // 成员函数
    int var;     // 成员变量
};               // 注意分号
```

对象的定义为：

```cpp
ClassName obj;       // 调用默认构造函数
ClassName obj(args); // 调用带参构造函数
ClassName obj();     // 函数声明，不是对象的定义
```

对象可以使用 `.` 运算符来访问成员，对象的指针可以使用 `->` 运算符来访问成员。

### 访问修饰符

关键字 `public` `private` `protected` 都是访问修饰符，区别如下：

- `public` 成员可以被任何函数访问
- `private` 成员只能被类的成员函数访问，类的成员默认为私有的
- `protected` 成员可以被类的成员函数和派生类的成员函数访问

### 成员函数

类的成员函数可以在类的内部定义，也可以在类的外部定义，外部定义时需要使用作用域解析运算符 `::` 来指明所属的类，例如 `void ClassName::func() { ... }`。

成员函数可以直接访问类所有的成员，也可以通过 `this` 指针来访问。`this` 指针指向当前对象，可以用于区分同名的成员变量和局部变量。

#### 构造函数

构造函数 (constructor) 是一类特殊的成员函数，它没有返回值，函数名为 `ClassName`，可以有多个重载版本。构造函数在对象创建时被调用，用于初始化对象的成员变量。

很多构造函数只需要初始化对象的成员变量，可以使用初始化列表来完成，初始化列表的语法为 `: member(args), ...`，具体示例如下：

```cpp
ClassName(int a, int b): var1(a), var2(b) { ... }
```

#### 析构函数

析构函数 (destructor) 是一类特殊的成员函数，它没有参数，没有返回值，函数名为 `~ClassName`，只有一个版本。析构函数在对象销毁时被调用，用于释放对象的资源。

如果一个类没有定义析构函数，编译器会自动生成一个默认的析构函数。对于简单的类，默认析构函数什么都不会做；若类中存在有自己的析构函数（不能是默认析构函数）的成员对象，默认析构函数会按逆序调用这些成员对象的析构函数（与它们在类定义中出现的顺序相反）。

#### 拷贝构造函数

拷贝构造函数 (copy constructor) 是一类特殊的构造函数，它只有一个参数，且参数为类的引用。拷贝构造函数在对象拷贝时被调用，用于初始化新对象的成员变量。

如果一个类没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，它会逐一拷贝对象的成员变量。但是如果类的成员变量是指针，这样的拷贝是浅拷贝，会导致指针指向同一个地址，可能会出现问题。可以通过定义自己的拷贝构造函数来解决这个问题，例如：

```cpp
ClassName(const ClassName & obj) {
    var = obj.var;
    ptr = new int(*obj.ptr);
}
```

### 友元函数

友元函数 (friend function) 不是类的成员函数，但可以访问类的私有成员和保护成员。若要声明函数为一个类的友元函数，需要在该类的定义中使用 `friend` 关键字，示例如下：

```cpp
class ClassB;
class ClassA {
    int var;
    friend void func(ClassA & a, ClassB & b);
};
class ClassB {
    int var;
    friend void func(ClassA & a, ClassB & b);
};

void func(ClassA & a, ClassB & b) {
    cout << a.var << endl;
    cout << b.var << endl;
}
```

友元类 (friend class) 与友元函数类似，不过它是一个类而不是一个函数。友元类的所有成员函数都是友元函数，可以通过 `friend class ClassName` 来声明。

### 内联函数

内联函数 (inline function) 通常用于定义简单的函数，它的定义为 `inline type func(args) { ... }`。当调用内联函数时，编译器会将函数的代码插入到调用的地方，而不是跳转到函数的地址，这样可以减少函数调用的开销。

### 静态成员

可以通过在成员定义的前面加上 `static` 关键字来定义静态成员，静态成员属于类而不属于对象，可以通过 `ClassName::member` 来访问。

静态成员变量只有一份拷贝，所有对象共享，会被初始化为零。

静态成员函数不属于任何对象，不需要通过对象来调用。它们只能访问静态成员变量和静态成员函数，不能访问对象的 this 指针和普通成员。

### 重载

重载 (overload) 是指在同一个作用域内，可以定义多个同名的函数，只要它们的参数列表不同。重载的函数可以有不同的返回值，但不能只有返回值不同。编译器会根据调用的参数类型来选择合适的函数。

除了函数重载以外，运算符也可以重载，重载运算符的语法为 `type operator op(args) { ... }`。type 的类型一般是该类本身，args 的类型一般是 `const ClassName &`，数量一般是 0 或 1 个，分别对应于一元运算符和二元运算符，但有一些特殊的运算符例外：

- `operator=` 重载时，返回类型是 `void`
- `operator[]` 重载时，args 一般是一个整数，表示下标
- `operator()` 重载时，args 可以是任意参数列表
- `operator++` 和 `operator--` 重载时，若 args 为空则表示是前缀运算符，若为 `int` 则表示是后缀运算符
- `operator<<` 和 `operator>>` 重载时，args 一般是 `ostream/istream &` 和 `ClassName &`，返回类型一般是 `ostream/istream &`。需要注意的是，如果要用到该类的私有成员，需要将该函数声明为友元函数。

大多数运算符是可以重载的，但有一些运算符是不可以重载的，例如 `.` `::` `.*` `?:` `sizeof` `typeid`。

### 继承

继承 (inheritance) 是面向对象编程的一个重要特性，它允许一个派生类继承另一个基类的成员。继承的语法为 `class DerivedClass: public BaseClass {...}`，其中 `public` 是继承方式，可以是 `public` `protected` `private`，区别如下：

- `public` 基类的公有成员仍是公有成员，保护成员仍是保护成员
- `protected` 基类的公有成员变为保护成员，保护成员仍是保护成员
- `private` 基类的公有成员和保护成员变为私有成员

派生类也可以继承多个基类，多个基类之间用逗号分隔，每个基类前需要指定继承方式。

可以在类名后加上 `final` 关键字来阻止类被继承，例如 `class ClassName final { ... }`；还可以在成员函数后加上 `final` 关键字来阻止函数被重写，例如 `void func() final { ... }`。

派生类会继承基类的所有成员，除了构造函数、析构函数、拷贝构造函数、友元函数和重载运算符。但是，派生类在初始化时，会隐式地调用基类的默认构造函数，如果基类没有默认构造函数，派生类必须通过初始化列表显式地调用基类的带参构造函数，例如 `DerivedClass(args) : BaseClass(args), ... { ... }`。

### 多态

多态 (polymorphism) 是面向对象编程的一个重要特性，它允许一个基类的指针指向一个派生类的对象，通过基类的指针调用派生类的成员函数。

多态可以通过虚函数 (virtual function) 来实现，虚函数可以通过在成员函数的前面加上 `virtual` 关键字来定义，这会让编译器在运行时动态绑定函数的地址。派生类重写的虚函数前面也可以加上 `virtual` 关键字作为提示，但不是必须的。

如果不想在基类中给出虚函数的实现，可以将虚函数定义为纯虚函数 (pure virtual function)，形式为 `virtual type func(args) = 0`。这会让基类变为抽象类，无法实例化，只能作为接口使用。

为了确认派生类成功重写了基类的虚函数，可以在基类的虚函数后面加上 `override` 关键字，例如 `void func() override { ... }`。这样的话，如果派生类没有成功重写基类的虚函数，编译器便会报错。`override` 关键字可以和 `final` 关键字一起使用，例如 `void func() final override { ... }`，顺序并不要紧。
