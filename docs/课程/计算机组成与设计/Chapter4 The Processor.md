
# 处理器

## 单周期 CPU 设计

处理器由控制单元和数据通路组成，其中数据通路包括多路选择器、ALU、寄存器等元件，控制单元负责根据指令的机器码选择不同的数据通路。

在单周期 CPU 中，每条指令都只在一个周期内完成，指令逐条执行。其中，每个指令都需要做的操作是：

- 从内存获得指令的机器码
- 得到下一条指令的地址

根据指令的类型，还可能进行的操作有：

- 使用 ALU 进行运算
- 向内存写入数据
- 从寄存器读取数据
- 向寄存器写入数据

获得机器码和读取寄存器的操作对每个指令来说都是一样的，可以共享相同的数据通路，而其他的操作则需要通过控制单元选择不同的数据通路来完成。

这里给出一个 Datapath 的示例：

![Datapath](../../assets/co_single_datapath.svg)


### 立即数处理

由 RISC-V 指令格式易得，不同类型的指令的立即数如下：

- I-type: `$signed({inst[31:20]})`
- S-type: `$signed({inst[31:25], inst[11:7]})`
- B-type: `$signed({inst[31], inst[7], inst[30:25], inst[11:8], 1'b0})`
- J-type: `$signed({inst[31], inst[19:12], inst[20], inst[30:21], 1'b0})`
- U-type: `{inst[31:12], 12'b0}`

控制单元需要根据指令的 opcode 获得对应的控制信号，来生成各种指令的立即数。


### ALU 运算

在 ALU 运算之前，要先根据指令的机器码，从寄存器中读取相应的 rs1 和 rs2，并生成相应的立即数。这里的实现是以 rs1 为第一个操作数，rs2 或 imm 为第二个操作数。

不同指令需要进行的运算操作为：

- `add` 等指令需要以 rs1 和 rs2 为操作数进行某些运算
- `addi` 等指令需要以 rs1 和 imm 为操作数进行某些运算
- `lw` `sw` 等指令需要以 rs1 和 imm 为操作数计算内存地址
- `beq` `blt` 等指令需要以 rs1 和 rs2 为操作数比较结果
- `jalr` 指令需要以 rs1 和 imm 为操作数计算跳转地址

可以看到，这些指令的运算只涉及 rs1, rs2 和 imm，因此我们只需做完简单连接，然后让控制单元根据指令机器码选择第二个操作数和 ALU 运算类型即可。

`lui` 和 `auipc` 的运算的操作数并不涉及寄存器，所以一般不在 ALU 中进行。需要注意的是，`beq` `blt` 等分支指令的运算也可以不在 ALU 中进行，直接在数据通路中构建电路，得到对应的分支跳转信号即可。


### 指令跳转

指令的跳转有四种可能：

- 跳转到顺序执行的下一条指令：是大多数指令的情况，也在分支指令失败时发生，需要计算 `PC + 4`
- 跳转到 PC 相对地址：在执行 jal 指令或分支指令成功时发生，需要计算 `PC + imm`
- 跳转到寄存器相对地址：在执行 jalr 指令时发生，需要计算 `rs1 + imm`

因此，可以使用一个四路选择器，根据指令的类型选择不同的跳转地址：

- 若为 jal 指令，则选择 `PC + imm`
- 若为分支指令，则根据比较结果选择 `PC + 4` 或 `PC + imm`
- 若为 jalr 指令，则选择 ALU 运算结果
- 若为其余指令，则选择 `PC + 4`

在运算出了跳转地址之后，我们在上升沿将 PC 更新为跳转地址，这样就实现了单周期 CPU 的指令跳转。

### 内存写入

`sb` `sh` `sw` 等指令都是写入 rs2，因此我们需要输出 rs2 作为写入数据。写入的数据可能不是四字节宽的，但是我们这里的 RAM 却是四字节写入，因此先将写入的数据左移到正确的位置，然后再写入。

例如，若要写入 `0xF8` 至地址 `0x0002`，则需要先将其左移变为 `0x00F80000`，再写入 RAM 中。需要移动的位数为 `addr % 4 * 8`，最终的表达式为 `data << (addr[1:0] << 3)`。

控制单元也需要相应地控制 RAM 的写入使能信号 wea。因为我们这里的 RAM 是四字节写入的，所以 wea 是四位的，每一位分别代表对应字节的读写信号。我们需要使得其每一位仅在需要被写入时为 1，其余任何时候都为 0。

需要注意的是，我们必须等到数据和地址都准备好之后再写入 RAM，否则若数据变化而地址未变，则会向之前的地址写入错误的数据。为此，可以将 RAM 的时钟置为 CPU 时钟的反，使得 RAM 在 CPU 时钟的下降沿写入数据，给 CPU 足够的时间准备。

### 内存读取

`lb` `lh` `lw` `lbu` 等指令读入的数据位宽不同，位宽不足时的扩展方式也不同。对于读入位宽小于 32 位的指令，我们可以先将读入数据右移，使得我们要读取的数据位于低位，然后再取低位对应宽度的数据进行扩展：

- `lw` 直接读入内存数据
- `lb` 读入 `$signed(shifted_data[7:0])`
- `lh` 读入 `$signed(shifted_data[15:0])`
- `lbu` 读入 `shifted_data[7:0]`
- `lhu` 读入 `shifted_data[15:0]`

右移数据的方式与写入内存时类似，需要右移 `addr[1:0] << 3` 位。

### 寄存器读写

寄存器可能会写入五种数据：

- `add` `addi` 等指令会写入 ALU 运算的结果
- `lb` `lw` 等指令会写入内存读取的数据
- `jal` 和 `jalr` 指令写入 `PC + 4`
- `lui` 指令会写入 `imm`
- `auipc` 指令会写入 `PC + imm`

控制单元在遇到上述指令时需要将寄存器写入使能信号 we 设置为 1，其余情况下为 0，同时在写入时，根据指令类型选择不同的写入数据。

获取寄存器的读写地址较为简单，直接将 `inst[19:15]` 作为 rs1 地址，`inst[24:20]` 作为 rs2 地址，`inst[11:7]` 作为 rd 地址输入即可。
