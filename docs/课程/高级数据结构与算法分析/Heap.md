
# 堆

## Leftist Heap

左偏树，也叫左倾堆，是一种二叉堆，和普通的堆有一样的顺序性质，但是不要求平衡，可以很快地完成合并操作。

对每个节点定义一个零距离 (Null Path Length, NPL)，即节点到最近的外部节点的距离，其中外部节点为没有两个子节点的节点。空节点的零距离为 -1，然后可以递归地得到其他节点的零距离：

$$NPL(x) = \min_{c\in \text{children of x}}(NPL(c)) + 1$$

左偏树的性质是：对于任意节点，它的左儿子的零距离大于等于右儿子的零距离。因此 $NLP(x) = NPL(x.\text{right}) + 1$。

### 合并

以小根堆为例，递归地合并两个左偏树的步骤如下：

1. 若有一个为空，则返回另一个
2. 比较两个根节点，将较小的根节点作为新根节点，保持新根节点的左子树不变，然后递归地合并其右子树与另一个左偏树，作为新根节点的右子树
3. 若合并后不满足左偏性质，则交换左右子树

迭代地合并两个左偏树的步骤如下：

1. 用两个指针分别指向两个左偏树的根节点，取出较小的一个作为新根节点，然后向右儿子移动对应指针
2. 不断取出两个指针指向的节点中较小的一个，作为上一个取出节点的右儿子，然后向右儿子移动对应指针，直至指针为空
3. 从最后一个取出的节点开始，不断调整左右子树以满足左偏性质，向上直至根节点

### 插入与删除

插入：将单个节点视为一个堆，合并到原堆即可中。

删除：将根节点删除，然后合并左右子树即可。

### 分析

定理：设右路径为从根节点开始一直往右走的路径，一个右路径包含 $r$ 个节点的左偏树最少有 $2^r - 1$ 个节点。

用数学归纳法证明：对于一个右路径节点数为 $k+1$ 的左偏树，其右子树的右路径节点数为 $k$，由 $NLP(x) = NPL(x.\text{right}) + 1$ 和 $NPL(x.\text{left}) \ge NPL(x.\text{right})$ 可得其左子树的右路径节点也应至少为 $k$，从而得该左偏树至少有 $2^k - 1 + 2^k - 1 + 1 = 2^{k+1} - 1$ 个节点。

因此，一个有 $n$ 个节点的左偏树的右路径节点数至多为 $\log(n+1)$。而上述操作均基于右路径进行，因此左偏树各操作的时间复杂度为 $O(\log n)$。




## Skew Heap

斜堆是一种二叉堆，与左偏树类似，但是不需要用到零距离，每一步都交换左右子树，除了右路径中最大的那个节点。斜堆的优点是不需要额外的空间来存储零距离，而且也不需要判断是否应该旋转。

斜堆的均摊时间复杂度也为 $O(\log n)$，可以通过势能分析来证明。

首先定义一个节点是重节点 (Heavy Node) 当且仅当其右子树的节点数大于左子树的节点数，否则就是轻节点 (Light Node)。然后定义势能函数 $\phi$ 为两个斜堆的重节点总数，$h$ 为两个斜堆除右路径外的重节点总数，$l_1, l_2$ 为两个斜堆右路径上的轻节点个数，$h_1, h_2$ 为两个斜堆右路径上的重节点个数。

这样以后，易得合并两个斜堆的实际代价为 $c = l_1 + h_1 + l_2 + h_2$，在合并前的势能为 $\Phi_0 = h_1 + h_2 + h$。

现在来看合并之后的重节点个数。因为右路径之外的重节点的儿子不会发生变化，因此 $h$ 是不变的。而在原右路径上的重节点，在交换前，其左子树节点数不变，右子树节点数要么不变要么变大，因此在交换后必然变为轻节点，从而有 $\Phi_N = l_1 + l_2 + h$。

因此合并操作的均摊代价为 $c + \Phi_N - \Phi_0 = 2(l_1 + l_2)$。

现让我们构造一个让右路径上的轻节点尽可能多的斜堆，在这个斜堆上，右路径上的每一个节点一方面需要让左子树节点多于右子树节点，另一方面需要让右子树节点数尽可能地多，以增长右路径，因此右路径上的每一个节点需要让左子树和右子树节点数相同，从而可得 $l = O(\log n)$，因此合并操作的均摊复杂度为 $O(\log n)$。
